<html>
  <head>
      <link href="style.css" rel="stylesheet" type="text/css" />
      <link href="http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css" rel="stylesheet" type="text/css" />
      <script src="http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js" type="text/javascript"></script>
      <script src="http://alexgorbatchev.com/pub/sh/current/scripts/shBrushJScript.js" type="text/javascript"></script>
      <script src="http://alexgorbatchev.com/pub/sh/current/scripts/shBrushXml.js" type="text/javascript"></script>
      <script src="http://alexgorbatchev.com/pub/sh/current/scripts/shBrushPython.js" type="text/javascript"></script>
      <script>
        SyntaxHighlighter.all();
      </script> 
  </head>
  <body>
<h1>Table of Contents</h1>
<div class="toc">
<ul>
<li><a href="#toc_1">Overview</a></li>
<ul>
<li><a href="#toc_1.1">Why choose a different semantics?</a></li>
</ul>
<li><a href="#toc_2">Similarities</a></li>
<li><a href="#toc_3">Differences</a></li>
<ul>
<li><a href="#toc_3.1">Event Lifeline</a></li>
<ul>
<li><a href="#toc_3.1.1">Sensing Events via Script</a></li>
<li><a href="#toc_3.1.2">Examples</a></li>
</ul>
<li><a href="#toc_3.2">Memory Protocol</a></li>
<ul>
<li><a href="#toc_3.2.1">Examples</a></li>
</ul>
<li><a href="#toc_3.3">Script evaluation scope</a></li>
<ul>
<li><a href="#toc_3.3.1">Example</a></li>
</ul>
</ul>
<li><a href="#toc_4">Where to learn more</a></li>
</ul>
</div>

<h1 id="toc_1">Overview</h1>

<p>
This document describes the similarities and differences between the semantics of SCION, and those of the "Algorithm for SCXML Interpretation" described in the SCXML draft specification. This document is targeted at developers already familiar with the "Algorithm for SCXML Interpretation", and who are interested in using SCION. Because this document is primarily targeted at developers familiar with the SCXML specification, the terminology used here will primarily be based on that of the SCXML specification, however some terminology from other papers will also be referred to.
</p>

<p>
All references to the "Algorithm for SCXML Interpretation" in this document are based on the <a href="http://www.w3.org/TR/2010/WD-scxml-20100513/">seventh Public Working Draft of SCXML, published on 13 May 2010</a>.
</p>

<h2 id="toc_1.1">Why choose a different semantics?</h2>

<p>
<img src="http://imgs.xkcd.com/comics/standards.png" />
</p>

<p>
There were a number of reasons to create a semantics different from those specified in the "Algorithm for SCXML Interpretation". The first is that the "Algorithm for SCXML Interpretation" <a href="http://lists.w3.org/Archives/Public/www-voice/2011JanMar/0033.html">contained a serious bug</a> regarding the execution of parallel states, such that the algorithm would cause the state machine interpreter to transition to illegal configurations for certain simple cases. It appeared as though this bug was not new, and had existed through several iterations of the specification, and it was uncertain whether and how the algorithm was being verified for correctness. Furthermore, the "Algorithm for SCXML Interpretation" diverged in unusual ways from the semantics of Statecharts defined in both "The Statemate Semantics of Statecharts" and "The Rhapsody Semantics of Statecharts" by David Harel, the creator of Statecharts. The motivation for these divergences was not always clear, and the fact that the W3C SCXML working group minutes were not publicly available made these choices difficult to investigate. 
</p>

<p>
For these reasons, I felt that it would be better to base the semantics of SCION on a strong theoretical foundation, and reuse well-known scholarly work on Statecharts semantics. I thus chose to base SCION semantics on the paper <a href="http://www.cs.uwaterloo.ca/~nday/Papers/uw-scs-tr-2009-05.pdf">"Big-Step Semantics"</a>, by Shahram Esmaeilsabzali, Nancy A. Day, Joanne M. Atlee, and Jianwei Niu. "Big-Step Semantics" describes eight semantic aspects that may be used to characterize the semantics of a Statecharts-like language. This allowed me to take the features of the "Algorithm for SCXML Interpretation" which I liked, and felt would be most salient to user interface developers, and ensure that other decisions regarding Statecharts semantic would also be well-founded.
</p>

<h1 id="toc_2">Similarities</h1>

<p>
Overall, I wanted the semantics of SCION to be well-defined with respect to the semantics described by "Big-Step Semantics", but to also be maximally intuitive for developers. There were many ideas in the "Algorithm for SCXML Interpretation" which I saw as being developer-friendly, and which were thus incorporated into the semantics of SCION. In general, SCION can be said to adhere to the general principles of <strong>Encapsulation, Causality, Determinism, Completeness, Run-to-completion, and Termination</strong>, as defined in "Algorithm for SCXML Interpretation". Specifically, some of the similarities between the "Algorithm for SCXML Interpretation" and SCION are as follows.
</p>

<p>
SCION adheres to run-to-completion semantics, where the system, when given an external event, will take multiple transitions, until it reaches a point where it is no longer possible to enable any further transitions.
</p>

<p>
SCION explicitly defines the order in which actions are executed when multiple transitions are enabled in the same microstep. The notion of using XML document order to define a total ordering on execution of transitions and entry and exit actions, and thus implicitly encode transition priority and eliminate non-determinism, seemed like an elegant and intuitive approach.
</p>

<p>
In SCION, the source state of a transition is also used to resolve conflicts when multiple transitions are activated, such that transitions originating from deeper in the state machine hierarchy have higher priority than their ancestors. This approach is similar to the notion of inheritance in Object-Oriented programming, in which a sub-class is able to override methods on the parent class, and I thus felt this notion would be most intuitive to developers. 
</p>

<p>
Finally, I liked the idea of using JavaScript, a general-purpose scripting language, as the action language in actions and guards of the state machine. This seemed well-aligned with the vision for SCION as being well-suited for developing user interfaces on the Web.
</p>

<h1 id="toc_3">Differences</h1>

<h2 id="toc_3.1">Event Lifeline</h2>

<p>
The "Event Lifeline" can be described as the question of when an internal event generated by SCXML &lt;send&gt; can be sensed by the state machine and used to trigger transitions.
</p>

<p>
For the purposes of this paper, the terms "big-step"/"macrostep", and "small-step"/"microstep", should be considered synonyms. The terms "macrostep" and "microstep" will be preferred, as they are used in the SCXML specification, but "big-step" and "small-step" will be used in the titles of the semantic choices, as these are taken directly from "Big-Step Semantics".
</p>

<p>
In SCXML semantics, exactly one event can be sensed at a time; if multiple send actions are triggered in a single microstep, then each of those send actions will add their event to the inner event queue. At the end of each microstep, an event is dequeued from the internal event queue, and this event is sensed in the next microstep. This continues until there are no longer any transitions enabled.
</p>

<p>
In "Big-Step Semantics", a set of events may be sensed in a single microstep. Four semantic choices are possible for this:
</p>
<ul>
<li>
Whole: a generated event
</li>
<ul>
<li>
is considered present from the beginning of the current macrostep, regardless of the microstep in which it has been generated; and
</li>
<li>
persists until the end of the macrostep
</li>
</ul>
<li>
Remainder: a generated event: 
</li>
<ul>
<li>
is considered present in the intermediate snapshot after the microstep that generates it, and 
</li>
<li>
persists during the remainder of the macrostep
</li>
</ul>
<li>
Next small-step: a generated event is present only for the next microstep
</li>
<li>
Same: a generated event is present during the current microstep
</li>
</ul>

<p>
I felt that the "next small-step" semantic choice would be most intuitive for developers. This means that if multiple send actions are fired in a single microstep, the events from both will be added to a <strong>single event set</strong>, potentially containing multiple individual events, which will be dequeued and sensed in the next microstep. This will continue until a macrostep occurs which does not enable any transitions.
</p>

<h3 id="toc_3.1.1">Sensing Events via Script</h3>

<p>
Because a <strong>set</strong> of events can be sensed in a microstep, rather than a single active event, the scripting interface to events must likewise be revised. The <code>_event</code> object available to SCXML action code is instead called <code>_events</code>, and contains a JavaScript array of event objects. Even though <code>_events</code> is exposed as an array, which is ordered, <strong>the order of events in the array is arbitrary and not meaningful</strong>. Individual events can be accessed by indexing into the array.
</p>

<p>
For convenience, and in order to provide a more familiar interface to SCXML developers, <code>_events[0]</code> is aliased to <code>_event</code>, which is also available to the scripting context.
</p>

<h3 id="toc_3.1.2">Examples</h3>

<p>
Consider the following example, which both SCION and the SCXML step algorithm should interpret the same.
</p>

<pre class="brush:xml">
&lt;scxml 
	xmlns="http://www.w3.org/2005/07/scxml"
	version="1.0"
	profile="ecmascript"
	id="root"&gt;

	&lt;initial id="intitial1"&gt;
		&lt;transition target="a"/&gt;
	&lt;/initial&gt;

	&lt;state id="a"&gt;
		&lt;transition target="b" event="t"&gt;
		&lt;/transition&gt;
	&lt;/state&gt;

	&lt;state id="b"&gt;
		&lt;onentry&gt;
			&lt;send event="s"/&gt;
		&lt;/onentry&gt;

		&lt;transition target="c" event="s"/&gt;
		&lt;transition target="f1"/&gt;
	&lt;/state&gt;

	&lt;state id="c"&gt;
		&lt;transition target="f2" event="s"/&gt;
		&lt;transition target="d"/&gt;
	&lt;/state&gt;

	&lt;state id="f1"&gt;
	&lt;/state&gt;

	&lt;state id="d"&gt;
	&lt;/state&gt;

	&lt;state id="f2"&gt;
	&lt;/state&gt;

&lt;/scxml&gt;
</pre>

<p>
The statechart begins in initial state <code>a</code>. Upon receiving event <code>t</code>, the statechart transitions to state <code>b</code>, which on entry sends event <code>s</code>. The microstep then ends, and the next microstep begins. The event <code>s</code>, triggered in the previous microstep, is sensed and the statechart transitions to state <code>c</code>, ignoring the default transition to state <code>f1</code>. The current microstep then ends, and the next microstep begins. The event <code>s</code> can no longer be sensed, and so the default transition to state <code>d</code> is then taken. 
</p>

<p>
Now consider the following example, which SCXML and SCION would interpret differently.
</p>

<pre class="brush:xml">
&lt;scxml 
	xmlns="http://www.w3.org/2005/07/scxml"
	version="1.0"
	profile="ecmascript"
	id="root"&gt;

	&lt;initial id="intitial1"&gt;
		&lt;transition target="a"/&gt;
	&lt;/initial&gt;

	&lt;state id="a"&gt;
		&lt;transition target="b" event="t"&gt;
		&lt;/transition&gt;
	&lt;/state&gt;

	&lt;state id="b"&gt;
		&lt;onentry&gt;
			&lt;send event="s"/&gt;
			&lt;send event="r"/&gt;
		&lt;/onentry&gt;

		&lt;transition target="c" event="s"/&gt;
		&lt;transition target="f1"/&gt;
	&lt;/state&gt;

	&lt;state id="c"&gt;
		&lt;transition target="f2" event="r"/&gt;
		&lt;transition target="d"/&gt;
	&lt;/state&gt;

	&lt;state id="f1"&gt;
	&lt;/state&gt;

	&lt;state id="d"&gt;
	&lt;/state&gt;

	&lt;state id="f2"&gt;
	&lt;/state&gt;

&lt;/scxml&gt;

</pre>

<p>
The statechart begins in initial state <code>a</code>. Upon receiving event <code>t</code>, the statechart transitions to state <code>b</code>, which on entry sends events <code>s</code> and <code>r</code>. The microstep then ends, and the next microstep begins. In SCION, events <code>s</code> and <code>r</code> could now be sensed; in SCXML, only event <code>s</code> could be sensed. In both SCION and SCXML, the event <code>s</code>, triggered in the previous microstep, would be sensed, and the statechart would transition to state <code>c</code>, ignoring the default transition to state <code>f1</code>. The current microstep then ends, and the next microstep begins. In SCION semantics, the event set containing <code>s</code> and <code>r</code> would already have been dequeued, so no events would be available to be sensed; the default transition would then be taken to state <code>d</code>. In SCXML, the event <code>r</code> would be dequeued, and the transition to state <code>f2</code> would instead be taken.  
</p>

<h2 id="toc_3.2">Memory Protocol</h2>

<p>
"Memory protocol" refers to the question of how to obtain the value of a variable in the statechart datamodel when it is accessed in a <a href="JavaScript.html">JavaScript</a> expression.
</p>

<p>
In the "Algorithm for SCXML Interpretation", variables in the datamodel can be assigned via &lt;assign&gt; tags, or via JavaScript assignment statements in action code. Assignment is performed synchronously, in the same microstep.
</p>

<p>
"Big-Step Semantics" describes two choices to assign values to variables in the statecharts datamodel:
</p>

<ul>
<li>
"Big-step", where variables stay the same throughout the macrostep, and are updated at the end of the macrostep.
</li>
<li>
"Small-step", where variables stay the same throughout the microstep, and are updated at the end of the microstep.
</li>
</ul>
	
<p>
Neither of these choices allow the kind of synchronous assignment that one finds in a typical procedural programming language. One consequence of this "double-buffering" of variables is additional overhead to the interpreter runtime, and more difficulty integrating these concepts with a general-purpose embedded scripting language. Furthermore, I feel that both of these choices are likely to be somewhat suprising and less intuitive to many web developers. Finally, the ability to enforce these semantics is limited in the browser environment (to my knowledge, there does not exist a general mechanism to sandbox arbitrary JavaScript assignments in the browser environment, and thus the developers would be able to side-step Memory Protocol semantics simply by assigning to global variables that are not declared in the datamodel). 
</p>

<p>
For that reason, SCION supports <strong>both</strong> synchronous assignment, such that assignment actions are detected in the same microstep, and optional "small-step" memory protocol semantics, in which assignment to variables in the datamodel are detected in the next microstep. This is managed as follows:
</p>

<ul>
<li>
Assignment performed by the &lt;assign&gt; tag uses "next small-step" semantics.
</li>
<li>
In JavaScript action code, JavaScript assignment statements uses ordinary JavaScript semantics to perform synchronous assignments to variables in the datamodel. This means that the datamodel will be updated immediately, after the statement executes, and these changes to the datamodel will be detectable in the same microstep. 
</li>
<li>
To use "next small-step" semantics in JavaScript action code, a getter and setter API is provided: 
</li>
<ul>
<li>
<code>setData(variableName,value)</code>
</li>
<li>
<code>getData(variableName)</code>
</li>
</ul>
</ul>

<h3 id="toc_3.2.1">Examples</h3>

<p>
Consider the following example:
</p>

<pre class="brush:xml">
&lt;scxml
	xmlns="http://www.w3.org/2005/07/scxml"
	version="1.0"
	profile="ecmascript"
	initial="a"&gt;

	&lt;datamodel&gt;
		&lt;data id="foo" expr="0"/&gt;
	&lt;/datamode&gt;

	&lt;state id="a"&gt;
		&lt;transition target="b" event="t"&gt;
			&lt;assign location="foo" expr="foo + 1"/&gt;
			&lt;assign location="foo" expr="foo - 1"/&gt;
		&lt;/transition&gt;
	&lt;/state&gt;

	&lt;state id="b"&gt;
		&lt;transition target="c"&gt;
			&lt;assign location="foo" expr="foo + 1"/&gt;
			&lt;assign location="foo" expr="foo - 1"/&gt;
		&lt;/transition&gt;
	&lt;/state&gt;

	&lt;state id="c"/&gt;
&lt;/scxml&gt;
</pre>

<p>
In this example, when the statechart is started, datamodel variable <code>foo</code> would be initialized to value <code>0</code>, and the statechart would begin in initial state <code>a</code>. Upon receiving event <code>t</code>, the transition actions would be executed in document order. Because the value of <code>foo</code> is only updated at the end of the microstep, the value of variable <code>foo</code> in the <code>expr</code> attribute of both assign actions in this transition will resolve to value <code>0</code>. Because, the assign action with expression <code>foo - 1</code> is executed after the assign action with expression <code>foo + 1</code>, at the end of the microstep <code>foo</code> will be assigned the value <code>foo - 1 = 0 - 1 = -1</code>. The statechart would end the microstep in state <code>b</code>. The next microstep would then begin, and the default transition to state <code>c</code> would then be taken. The same actions would be performed, and so at the end of the microstep, variable <code>foo</code> would be updated to value <code>foo - 1 = -1 - 1 = -2</code>. 
</p>

<p>
The above example is equivalent to the following:
</p>

<pre class="brush:js;html-script:true;">
&lt;scxml
	xmlns="http://www.w3.org/2005/07/scxml"
	version="1.0"
	profile="ecmascript"
	initial="a"&gt;

	&lt;datamodel&gt;
		&lt;data id="foo" expr="0"/&gt;
	&lt;/datamode&gt;

	&lt;state id="a"&gt;
		&lt;transition target="b" event="t"&gt;
			&lt;script&gt;
				setData('foo',getData('foo') + 1);
				setData('foo',getData('foo') - 1);
			&lt;/script&gt;
		&lt;/transition&gt;
	&lt;/state&gt;

	&lt;state id="b"&gt;
		&lt;transition target="c"&gt;
			&lt;script&gt;
				setData('foo',getData('foo') + 1);
				setData('foo',getData('foo') - 1);
			&lt;/script&gt;
		&lt;/transition&gt;
	&lt;/state&gt;

	&lt;state id="c"/&gt;
&lt;/scxml&gt;
</pre>

<p>
The following is an example of the way synchronous assignment may be used in SCION:
</p>

<pre class="brush:js;html-script:true;">
&lt;scxml
	xmlns="http://www.w3.org/2005/07/scxml"
	version="1.0"
	profile="ecmascript"
	initial="a"&gt;

	&lt;datamodel&gt;
		&lt;data id="foo" expr="0"/&gt;
	&lt;/datamode&gt;

	&lt;state id="a"&gt;
		&lt;transition target="b" event="t"&gt;
			&lt;script&gt;
				foo = foo + 1;
				foo = foo - 1;
			&lt;/script&gt;
		&lt;/transition&gt;
	&lt;/state&gt;

	&lt;state id="b"&gt;
		&lt;transition target="c"&gt;
			&lt;script&gt;
				foo = foo + 1;
				foo = foo - 1;
			&lt;/script&gt;
		&lt;/transition&gt;
	&lt;/state&gt;

	&lt;state id="c"/&gt;
&lt;/scxml&gt;
</pre>

<p>
Like the first two examples, the statechart will begin in state <code>a</code>, variable <code>foo</code> will be initialized to value <code>0</code>, and upon receiving event <code>t</code>, the statechart will transition to state <code>b</code>. The JavaScript statements in the script action will be executed, and <code>foo</code> will be updated synchronously. This means that the first JavaScript statement, <code>foo = foo + 1;</code>, will assign the value <code>0 + 1 = 1</code> to variable <code>foo</code>. The second JavaScript statement, <code>foo = foo - 1;</code>, will assign the value <code>1 - 1 = 0</code> to <code>foo</code>. The same would be repeated in the next microstep, in the default transition from state <code>b</code> to state <code>c</code>. Thus, <code>foo</code> would end with value <code>0</code>.
</p>

<p>
The following is an example of how "next small-step" assignment semantics would work in a parallel state:
</p>

<pre class="brush:xml">
&lt;scxml
	xmlns="http://www.w3.org/2005/07/scxml"
	version="1.0"
	profile="ecmascript"
	initial="a"&gt;

	&lt;datamodel&gt;
		&lt;data id="foo" expr="0"/&gt;
	&lt;/datamode&gt;

	&lt;parallel id="a"&gt;
		&lt;state id="b"&gt;
			&lt;onexit&gt;
				&lt;assign location="foo" expr="foo + 1"/&gt;
			&lt;/onexit&gt;
		&lt;/state&gt;

		&lt;state id="c"&gt;
			&lt;onexit&gt;
				&lt;assign location="foo" expr="foo - 1"/&gt;
			&lt;/onexit&gt;
		&lt;/state&gt;

		&lt;transition target="d" event="t"/&gt;

	&lt;/parallel&gt;

	&lt;state id="d"/&gt;

&lt;/scxml&gt;
</pre>

<p>
In this example, the state machine would begin in parallel state <code>a</code> and basic states <code>b</code> and <code>c</code>, and variable <code>foo</code> would be initialized to value <code>0</code>. Upon receiving event <code>t</code>, the statechart would transition to state <code>d</code>. This would trigger the onexit assign actions of both states <code>b</code> and <code>c</code>. These assign actions would be executed in document order, which means that the assign action originating in state <code>b</code> would be executed before that originating in state <code>c</code>. Expression <code>foo - 1</code> is thus evaluated after <code>foo + 1</code>. Because these assignments take place within the same small step, <code>foo - 1</code> will resolve <code>foo</code> to have the value it had at the beginning of the microstep, which is value <code>0</code>. Thus, <code>foo</code> would be assigned <code>foo - 1 = 0 - 1 = -1</code> for the next microstep.
</p>

<h2 id="toc_3.3">Script evaluation scope</h2>

<p>
The scope in which action code is executed is not explicitly specified in the "Algorithm for SCXML Interpretation".
</p>

<p>
In SCION, top-level script elements (those that are children of the root &lt;scxml&gt; element) are evaluated in the global scope. In this way, global variables, including functions, may be defined by the SCXML model, which are available to all action code that will be executed, as well as any other code that shares the same global scope.
</p>

<p>
All other action code is evaluated in a restricted scope. Local variables <code>getData</code>, <code>setData</code>, <code>_events</code>, <code>_event</code>, and <code>In</code>, as defined in this document and the SCXML specification, are available as local variables to the evaluating script context. Furthermore, datamodel variables are available as local variables, so that they can be assigned to directly, without declaring global variables.
</p>

<h3 id="toc_3.3.1">Example</h3>

<p>
The following simplified example is from <a href="http://jbeard4.github.com/SCION/demos/drag-and-drop/drag-and-drop.xhtml">here</a>.
</p>

<pre class="brush:js;html-script:true;">
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg"&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body&gt;
    &lt;svg xmlns="http://www.w3.org/2000/svg"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:scion="https://github.com/jbeard4/SCION" width="100%" height="99%" &gt;

      &lt;rect width="100" height="100" stroke="black" fill="red" id="rectToTranslate" &gt;
        &lt;scxml 
          xmlns="http://www.w3.org/2005/07/scxml"
          version="1.0"
          profile="ecmascript"
          id="scxmlRoot"
          initial="idle"&gt;

          &lt;script&gt;
            function computeTDelta(oldEvent,newEvent){
              //summary:computes the offset between two events; to be later
              //used with this.translate
              var dx = newEvent.clientX - oldEvent.clientX;
              var dy = newEvent.clientY - oldEvent.clientY;

              return {'dx':dx,'dy':dy};
            }

            function translate(rawNode,tDelta){
              var tl = rawNode.transform.baseVal;
              var t = tl.numberOfItems ? 
                tl.getItem(0) : 
                rawNode.ownerSVGElement.createSVGTransform();
              var m = t.matrix;
              var newM = rawNode.ownerSVGElement.
                createSVGMatrix().
                translate(tDelta.dx,tDelta.dy).multiply(m);
              t.setMatrix(newM);
              tl.initialize(t);
              return newM;
            }
          &lt;/script&gt;

          &lt;datamodel&gt;
            &lt;data id="firstEvent"/&gt;
            &lt;data id="eventStamp"/&gt;
            &lt;data id="tDelta"/&gt;
          &lt;/datamodel&gt;

          &lt;state id="idle"&gt;
            &lt;transition event="mousedown" target="dragging"&gt;
              &lt;assign location="firstEvent" expr="_event.data"/&gt;
              &lt;assign location="eventStamp" expr="_event.data"/&gt;
            &lt;/transition&gt;
          &lt;/state&gt;

          &lt;state id="dragging"&gt;
            &lt;transition event="mouseup" target="idle"/&gt;

            &lt;transition event="mousemove" target="dragging"&gt;
              &lt;script&gt;
                tDelta = computeTDelta(eventStamp,_event.data);
                translate(this,tDelta);
              &lt;/script&gt;
              &lt;assign location="eventStamp" expr="_event.data"/&gt;
            &lt;/transition&gt;
          &lt;/state&gt;

        &lt;/scxml&gt;
      &lt;/rect&gt;
    &lt;/svg&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
In this example, functions <code>computeTDelta</code> and <code>translate</code> would be declared in the global scope.
Datamodel variables <code>firstEvent</code>, <code>eventStamp</code>, and <code>tDelta</code>, as well as the event variable <code>_event</code>, would only be available as local variables in the restricted context in which action code is evaluated. Datamodel variables may be assign to directly, as is done in the JavaScript statement <code>tDelta = computeTDelta(eventStamp,_event.data);</code>.
</p>

<h1 id="toc_4">Where to learn more</h1>

<ul>
<li>
<a href="Pseudocode for SCION step algorithm.html">Pseudocode for SCION step algorithm</a>
</li>
<li>
<a href="SCION Semantics.html">SCION Semantics</a>
</li>
<li>
<a href="http://www.cs.uwaterloo.ca/~nday/Papers/uw-scs-tr-2009-05.pdf">"Big-Step Semantics"</a>
</li>
</ul>

</body>
</html>
